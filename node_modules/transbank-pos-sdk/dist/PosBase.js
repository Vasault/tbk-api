"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var LRC = require("lrc-calculator");

var SerialPort = require("serialport");

var EventEmitter = require('events');

var InterByteTimeout = require("@serialport/parser-inter-byte-timeout");

var responseMessages = require("./responseCodes");

var ACK = 0x06;

module.exports = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2["default"])(POSBase, _EventEmitter);

  var _super = _createSuper(POSBase);

  function POSBase() {
    var _this;

    (0, _classCallCheck2["default"])(this, POSBase);
    _this = _super.call(this);
    _this.currentPort = null;
    _this.connected = false;
    _this.defaultBaudRate = _this.constructor.name === 'POSAutoservicio' ? 19200 : 115200;
    _this.ackTimeout = 2000;
    _this.posTimeout = 150000;
    _this.debugEnabled = false;
    _this.port = null;
    _this.responseAsString = true;
    _this.waiting = false;
    _this.connecting = false;

    _this.responseCallback = function () {};

    _this.ackCallback = function () {};

    return _this;
  }
  /*
   |--------------------------------------------------------------------------
   | Getters and Setters
   |--------------------------------------------------------------------------
   */


  (0, _createClass2["default"])(POSBase, [{
    key: "debug",
    value: function debug() {
      if (this.debugEnabled) {
        var _console;

        (_console = console).log.apply(_console, arguments);
      }
    }
  }, {
    key: "setDebug",
    value: function setDebug() {
      var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.debugEnabled = debug;
    }
  }, {
    key: "getResponsesAsString",
    value: function getResponsesAsString() {
      this.responseAsString = true;
    }
  }, {
    key: "getResponsesAsHexArray",
    value: function getResponsesAsHexArray() {
      this.responseAsString = false;
    }
  }, {
    key: "getConnectedPort",
    value: function getConnectedPort() {
      return this.currentPort;
    }
  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.connected;
    }
  }, {
    key: "raw_serial_port",
    value: function raw_serial_port() {
      return this.port;
    }
  }, {
    key: "raw_parser",
    value: function raw_parser() {
      return this.parser;
    }
  }, {
    key: "listPorts",
    value: function listPorts() {
      return SerialPort.list();
    }
  }, {
    key: "bufferToPrintableString",
    value: function bufferToPrintableString(buffer) {
      var printableString = "";
      var lrcIndex = buffer.length - 1;
      buffer.forEach(function (_char, index) {
        if (index === lrcIndex) {
          printableString += "{0x".concat(_char.toString(16).padStart(2, "0"), "}");
        } else {
          printableString += 32 <= _char && _char < 126 ? String.fromCharCode(_char) : "{0x".concat(_char.toString(16).padStart(2, "0"), "}");
        }
      });
      return printableString;
    }
    /*
     |--------------------------------------------------------------------------
     | Serial Port Handling
     |--------------------------------------------------------------------------
     */

  }, {
    key: "connect",
    value: function connect() {
      var _this2 = this;

      var portName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var baudRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBaudRate;
      this.debug("Connecting to " + portName + " @" + baudRate);
      return new Promise(function (resolve, reject) {
        // Block so just one connect command can be sent at a time
        if (_this2.connecting === true) {
          return reject(new Error("Another connect command was already sent and it is still waiting"));
        }

        if (_this2.connected) {
          _this2.debug("Trying to connect to a port while its already connected. Disconnecting... ");

          _this2.disconnect().then(function () {
            resolve(_this2.connect(portName, baudRate));
          })["catch"](function () {
            resolve(_this2.connect(portName, baudRate));
          });

          _this2.connecting = false;
          return;
        }

        _this2.connecting = true;
        _this2.port = new SerialPort(portName, {
          baudRate: baudRate,
          autoOpen: false
        });

        _this2.port.open(function (err) {
          if (err) {
            _this2.debug("Error opening port", err);

            return reject(new Error('Could not open serial connection...'));
          }
        });

        _this2.parser = _this2.port.pipe(new InterByteTimeout({
          interval: 100
        }));

        _this2.parser.on("data", function (data) {
          _this2.debug("IN <-- ".concat(_this2.bufferToPrintableString(data))); // Primero, se recibe un ACK


          if (_this2.itsAnACK(data)) {
            if (typeof _this2.ackCallback === "function") {
              _this2.ackCallback(data);
            }

            return;
          } // Si se recibiÃ³ una respuesta (diferente a un ACK) entonces responder con un ACK y mandar el mensaje por callback


          _this2.port.write(Buffer.from([ACK]));

          _this2.debug("OUT --> ".concat(_this2.bufferToPrintableString([ACK])));

          if (typeof _this2.responseCallback === "function") {
            _this2.responseCallback(data);
          }
        }); // will emit data if there is a pause between packets of at least 30ms


        _this2.port.on("open", function () {
          _this2.debug("Port opened");

          _this2.connected = true;

          _this2.poll().then(function () {
            _this2.currentPort = portName;

            _this2.emit('port_opened', _this2.currentPort);

            resolve(true);
          })["catch"]( /*#__PURE__*/function () {
            var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(e) {
              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _this2.connected = false;
                      _this2.waiting = false;
                      _this2.currentPort = null;

                      if (!_this2.port.isOpen) {
                        _context.next = 6;
                        break;
                      }

                      _context.next = 6;
                      return _this2.disconnect();

                    case 6:
                      reject(e);

                    case 7:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            return function (_x) {
              return _ref.apply(this, arguments);
            };
          }());
        });

        _this2.port.on("close", function () {
          _this2.debug("Port closed");

          _this2.currentPort = null;
          _this2.waiting = false;
          _this2.connected = false;

          _this2.emit('port_closed');
        });

        _this2.connecting = false;
      });
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (!_this3.port.isOpen) {
          resolve(true);
          return;
        }

        _this3.port.close(function (error) {
          if (error) {
            _this3.debug("Error closing port", error);

            reject(error);
          } else {
            _this3.debug("Port closed successfully");

            resolve(true);
          }
        });
      });
    }
  }, {
    key: "autoconnect",
    value: function () {
      var _autoconnect = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var baudrate,
            ports,
            _iterator,
            _step,
            port,
            _args2 = arguments;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                baudrate = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : this.defaultBaudRate;

                if (!(this.connecting === true)) {
                  _context2.next = 4;
                  break;
                }

                this.debug("It is already trying to connect. Please wait for it to finish");
                return _context2.abrupt("return", false);

              case 4:
                _context2.next = 6;
                return this.listPorts();

              case 6:
                ports = _context2.sent;
                _iterator = _createForOfIteratorHelper(ports);
                _context2.prev = 8;

                _iterator.s();

              case 10:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 25;
                  break;
                }

                port = _step.value;
                this.debug("Trying to connect to " + port.path);
                _context2.prev = 13;
                _context2.next = 16;
                return this.connect(port.path, baudrate);

              case 16:
                this.connecting = false;
                return _context2.abrupt("return", port);

              case 20:
                _context2.prev = 20;
                _context2.t0 = _context2["catch"](13);
                console.log(_context2.t0);

              case 23:
                _context2.next = 10;
                break;

              case 25:
                _context2.next = 30;
                break;

              case 27:
                _context2.prev = 27;
                _context2.t1 = _context2["catch"](8);

                _iterator.e(_context2.t1);

              case 30:
                _context2.prev = 30;

                _iterator.f();

                return _context2.finish(30);

              case 33:
                this.connecting = false;
                this.debug("Autoconnection failed");
                return _context2.abrupt("return", false);

              case 36:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[8, 27, 30, 33], [13, 20]]);
      }));

      function autoconnect() {
        return _autoconnect.apply(this, arguments);
      }

      return autoconnect;
    }()
  }, {
    key: "send",
    value: function send(payload) {
      var _this4 = this;

      var waitResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return new Promise(function (resolve, reject) {
        if (!_this4.connected) {
          return reject(new Error("You have to connect to a POS to send this message: " + payload.toString()));
        } // Block so just one message can be sent at a time


        if (_this4.waiting === true) {
          return reject(new Error("Another message was already sent and it is still waiting for a response from the POS"));
        }

        _this4.waiting = true; // Assert the ack arrives before the given timeout.

        var timeout = setTimeout(function () {
          _this4.waiting = false;
          clearTimeout(responseTimeout);
          reject(new Error("ACK has not been received in " + _this4.ackTimeout + " ms."));
        }, _this4.ackTimeout); // Defines what should happen when the ACK is received

        _this4.ackCallback = function () {
          clearTimeout(timeout);

          if (!waitResponse) {
            _this4.waiting = false;
            resolve(true);
          }
        }; // Prepare the message


        var buffer = Buffer.from(LRC.asStxEtx(payload));

        _this4.debug("OUT --> ".concat(_this4.bufferToPrintableString(buffer))); //Send the message


        _this4.port.write(buffer, function (err) {
          if (err) {
            this.debug("Error sending message", err);
            reject(new Error('Failed to send message to POS.'));
          }
        });

        var responseTimeout = setTimeout(function () {
          _this4.waiting = false;
          reject(new Error("Response of POS has not been received in ".concat(_this4.posTimeout / 1000, " seconds")));
        }, _this4.posTimeout); // Wait for the response and fullfill the Promise

        _this4.responseCallback = function (data) {
          clearTimeout(responseTimeout);
          var response = data;

          if (_this4.responseAsString) {
            response = data.toString().slice(1, -2);
          }

          var functionCode = data.toString().slice(1, 5);

          if (functionCode === "0900") {
            // Sale status messages
            if (typeof callback === "function") {
              callback(_this4.intermediateResponse(response), data);
            }

            return;
          }

          if (functionCode === "0261") {
            if (typeof callback === "function") {
              callback(response, data);
            }

            return;
          }

          _this4.waiting = false;
          resolve(response, data);
        };
      });
    }
  }, {
    key: "getResponseMessage",
    value: function getResponseMessage(response) {
      return typeof responseMessages[response] !== "undefined" ? responseMessages[response] : null;
    }
  }, {
    key: "itsAnACK",
    value: function itsAnACK(data) {
      return Buffer.compare(data, Buffer.from([ACK])) === 0;
    }
    /*  
     |--------------------------------------------------------------------------
     | Shared Commands
     |--------------------------------------------------------------------------
    */

  }, {
    key: "poll",
    value: function poll() {
      return this.send("0100", false);
    }
  }, {
    key: "loadKeys",
    value: function loadKeys() {
      var _this5 = this;

      return this.send("0800").then(function (data) {
        var chunks = data.split("|");
        return {
          functionCode: parseInt(chunks[0]),
          responseCode: parseInt(chunks[1]),
          commerceCode: parseInt(chunks[2]),
          terminalId: chunks[3],
          responseMessage: _this5.getResponseMessage(parseInt(chunks[1])),
          successful: parseInt(chunks[1]) === 0
        };
      });
    }
  }, {
    key: "intermediateResponse",
    value: function intermediateResponse(payload) {
      var chunks = payload.split("|");
      var response = {
        responseCode: parseInt(chunks[1]),
        responseMessage: this.getResponseMessage(parseInt(chunks[1]))
      };
      return response;
    }
  }]);
  return POSBase;
}(EventEmitter);